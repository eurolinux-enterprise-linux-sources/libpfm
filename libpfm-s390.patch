commit 9b38b5435de72ae4253bd8a6d6558e50fff618e7
Author: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Date:   Fri Feb 17 15:50:14 2017 +0100

    s390/cpumf: add support for IBM z13/z13s counters
    
    This commit adds the counter definitions for the IBM z13/z13s
    specific counters.  These counters are available in the extended
    and the new MT-diagnostic counter sets.
    
    Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>

diff --git a/lib/events/s390x_cpumf_events.h b/lib/events/s390x_cpumf_events.h
index e00b088..be9d7d9 100644
--- a/lib/events/s390x_cpumf_events.h
+++ b/lib/events/s390x_cpumf_events.h
@@ -11,6 +11,7 @@
 #define CPUMF_CTRSET_PROBLEM_STATE      4
 #define CPUMF_CTRSET_CRYPTO             8
 #define CPUMF_CTRSET_EXTENDED           1
+#define CPUMF_CTRSET_MT_DIAG            32
 
 
 static const pme_cpumf_ctr_t cpumcf_generic_counters[] = {
@@ -840,6 +841,458 @@ static const pme_cpumf_ctr_t cpumcf_zec12_counters[] = {
 	},
 };
 
+static const pme_cpumf_ctr_t cpumcf_z13_counters[] = {
+	{
+		.ctrnum = 128,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_WRITES_RO_EXCL",
+		.desc = "Counter:128 Name:L1D_WRITES_RO_EXCL A directory"
+			" write to the Level-1 Data cache where the line was"
+			" originally in a Read-Only state in the cache but"
+			" has been updated to be in the Exclusive state that"
+			" allows stores to the cache line.",
+	},
+	{
+		.ctrnum = 129,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "DTLB1_WRITES",
+		.desc = "A translation entry has been written to the Level-1"
+			" Data Translation Lookaside Buffer",
+	},
+	{
+		.ctrnum = 130,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "DTLB1_MISSES",
+		.desc = "Level-1 Data TLB miss in progress. Incremented by"
+			" one for every cycle a DTLB1 miss is in progress.",
+	},
+	{
+		.ctrnum = 131,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "DTLB1_HPAGE_WRITES",
+		.desc = "A translation entry has been written to the Level-1"
+			" Data Translation Lookaside Buffer for a one-"
+			" megabyte page",
+	},
+	{
+		.ctrnum = 132,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "DTLB1_GPAGE_WRITES",
+		.desc = "Counter:132 Name:DTLB1_GPAGE_WRITES A translation"
+			" entry has been written to the Level-1 Data"
+			" Translation Lookaside Buffer for a two-gigabyte"
+			" page.",
+	},
+	{
+		.ctrnum = 133,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_L2D_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from the Level-2 Data cache",
+	},
+	{
+		.ctrnum = 134,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "ITLB1_WRITES",
+		.desc = "A translation entry has been written to the Level-1"
+			" Instruction Translation Lookaside Buffer",
+	},
+	{
+		.ctrnum = 135,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "ITLB1_MISSES",
+		.desc = "Level-1 Instruction TLB miss in progress."
+			" Incremented by one for every cycle an ITLB1 miss is"
+			" in progress",
+	},
+	{
+		.ctrnum = 136,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_L2I_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from the Level-2 Instruction cache",
+	},
+	{
+		.ctrnum = 137,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TLB2_PTE_WRITES",
+		.desc = "A translation entry has been written to the Level-2"
+			" TLB Page Table Entry arrays",
+	},
+	{
+		.ctrnum = 138,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TLB2_CRSTE_HPAGE_WRITES",
+		.desc = "A translation entry has been written to the Level-2"
+			" TLB Combined Region Segment Table Entry arrays for"
+			" a one-megabyte large page translation",
+	},
+	{
+		.ctrnum = 139,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TLB2_CRSTE_WRITES",
+		.desc = "A translation entry has been written to the Level-2"
+			" TLB Combined Region Segment Table Entry arrays",
+	},
+	{
+		.ctrnum = 140,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TX_C_TEND",
+		.desc = "A TEND instruction has completed in a constrained"
+			" transactional-execution mode",
+	},
+	{
+		.ctrnum = 141,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TX_NC_TEND",
+		.desc = "A TEND instruction has completed in a non-"
+			" constrained transactional-execution mode",
+	},
+	{
+		.ctrnum = 143,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1C_TLB1_MISSES",
+		.desc = "Increments by one for any cycle where a Level-1"
+			" cache or Level-1 TLB miss is in progress.",
+	},
+	{
+		.ctrnum = 144,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONCHIP_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Chip Level-3 cache without intervention",
+	},
+	{
+		.ctrnum = 145,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONCHIP_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Chip Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 146,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONNODE_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Node Level-4 cache",
+	},
+	{
+		.ctrnum = 147,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONNODE_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Node Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 148,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONNODE_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Node Level-3 cache without intervention",
+	},
+	{
+		.ctrnum = 149,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONDRAWER_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Drawer Level-4 cache",
+	},
+	{
+		.ctrnum = 150,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONDRAWER_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Drawer Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 151,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONDRAWER_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Drawer Level-3 cache without"
+			" intervention",
+	},
+	{
+		.ctrnum = 152,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_SCOL_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Same-Column Level-4 cache",
+	},
+	{
+		.ctrnum = 153,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_SCOL_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Same-Column Level-3 cache with"
+			" intervention",
+	},
+	{
+		.ctrnum = 154,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_SCOL_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Same-Column Level-3 cache"
+			" without intervention",
+	},
+	{
+		.ctrnum = 155,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_FCOL_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Far-Column Level-4 cache",
+	},
+	{
+		.ctrnum = 156,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_FCOL_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Far-Column Level-3 cache with"
+			" intervention",
+	},
+	{
+		.ctrnum = 157,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_FCOL_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Far-Column Level-3 cache without"
+			" intervention",
+	},
+	{
+		.ctrnum = 158,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONNODE_MEM_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from On-Node memory",
+	},
+	{
+		.ctrnum = 159,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONDRAWER_MEM_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from On-Drawer memory",
+	},
+	{
+		.ctrnum = 160,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_MEM_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from On-Drawer memory",
+	},
+	{
+		.ctrnum = 161,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONCHIP_MEM_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from On-Chip memory",
+	},
+	{
+		.ctrnum = 162,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONCHIP_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Chip Level-3 cache without intervention",
+	},
+	{
+		.ctrnum = 163,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONCHIP_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an On Chip Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 164,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONNODE_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Node Level-4 cache",
+	},
+	{
+		.ctrnum = 165,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONNODE_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Node Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 166,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONNODE_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Node Level-3 cache without intervention",
+	},
+	{
+		.ctrnum = 167,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONDRAWER_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Drawer Level-4 cache",
+	},
+	{
+		.ctrnum = 168,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONDRAWER_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Drawer Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 169,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONDRAWER_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Drawer Level-3 cache without"
+			" intervention",
+	},
+	{
+		.ctrnum = 170,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_SCOL_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Same-Column Level-4 cache",
+	},
+	{
+		.ctrnum = 171,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_SCOL_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Same-Column Level-3 cache with"
+			" intervention",
+	},
+	{
+		.ctrnum = 172,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_SCOL_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Same-Column Level-3 cache"
+			" without intervention",
+	},
+	{
+		.ctrnum = 173,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_FCOL_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Far-Column Level-4 cache",
+	},
+	{
+		.ctrnum = 174,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_FCOL_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Far-Column Level-3 cache with"
+			" intervention",
+	},
+	{
+		.ctrnum = 175,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_FCOL_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Far-Column Level-3 cache without"
+			" intervention",
+	},
+	{
+		.ctrnum = 176,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONNODE_MEM_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from On-Node memory",
+	},
+	{
+		.ctrnum = 177,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONDRAWER_MEM_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from On-Drawer memory",
+	},
+	{
+		.ctrnum = 178,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_MEM_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from On-Drawer memory",
+	},
+	{
+		.ctrnum = 179,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONCHIP_MEM_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from On-Chip memory",
+	},
+	{
+		.ctrnum = 218,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TX_NC_TABORT",
+		.desc = "A transaction abort has occurred in a non-"
+			" constrained transactional-execution mode",
+	},
+	{
+		.ctrnum = 219,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TX_C_TABORT_NO_SPECIAL",
+		.desc = "A transaction abort has occurred in a constrained"
+			" transactional-execution mode and the CPU is not"
+			" using any special logic to allow the transaction to"
+			" complete",
+	},
+	{
+		.ctrnum = 220,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TX_C_TABORT_SPECIAL",
+		.desc = "A transaction abort has occurred in a constrained"
+			" transactional-execution mode and the CPU is using"
+			" special logic to allow the transaction to complete",
+	},
+	{
+		.ctrnum = 448,
+		.ctrset = CPUMF_CTRSET_MT_DIAG,
+		.name = "MT_DIAG_CYCLES_ONE_THR_ACTIVE",
+		.desc = "Cycle count with one thread active",
+	},
+	{
+		.ctrnum = 449,
+		.ctrset = CPUMF_CTRSET_MT_DIAG,
+		.name = "MT_DIAG_CYCLES_TWO_THR_ACTIVE",
+		.desc = "Cycle count with two threads active",
+	},
+};
+
 static const pme_cpumf_ctr_t cpumsf_counters[] = {
 	{
 		.ctrnum = 720896,
diff --git a/lib/pfmlib_s390x_cpumf.c b/lib/pfmlib_s390x_cpumf.c
index b5444ef..7273962 100644
--- a/lib/pfmlib_s390x_cpumf.c
+++ b/lib/pfmlib_s390x_cpumf.c
@@ -128,6 +128,11 @@ static int pfm_cpumcf_init(void *this)
 		ext_set = cpumcf_zec12_counters;
 		ext_set_count = LIBPFM_ARRAY_SIZE(cpumcf_zec12_counters);
 		break;
+	case 2964:  /* IBM z13  */
+	case 2965:  /* IBM z13s */
+		ext_set = cpumcf_z13_counters;
+		ext_set_count = LIBPFM_ARRAY_SIZE(cpumcf_z13_counters);
+		break;
 	default:
 		/* No extended counter set for this machine type or there
 		 * was an error retrieving the machine type */
commit 8f2653b8e2e18bad44ba1acc7f92c825f226ef71
Author: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Date:   Fri Oct 13 16:57:32 2017 +0200

    s390/cpumf: add support for IBM z14 counters
    
    Add counter definitions for the IBM z14 hardware model.  With z14,
    the counters in the problem-state set are reduced and the counter
    first number version is increased accordingly.  Now, the counters
    are processed depending on the counter facility versions.
    
    Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>

diff --git a/lib/events/s390x_cpumf_events.h b/lib/events/s390x_cpumf_events.h
index be9d7d9..c843bc3 100644
--- a/lib/events/s390x_cpumf_events.h
+++ b/lib/events/s390x_cpumf_events.h
@@ -14,7 +14,7 @@
 #define CPUMF_CTRSET_MT_DIAG            32
 
 
-static const pme_cpumf_ctr_t cpumcf_generic_counters[] = {
+static const pme_cpumf_ctr_t cpumcf_fvn1_counters[] = {
 	{
 		.ctrnum = 0,
 		.ctrset = CPUMF_CTRSET_BASIC,
@@ -87,6 +87,60 @@ static const pme_cpumf_ctr_t cpumcf_generic_counters[] = {
 		.name = "PROBLEM_STATE_L1D_PENALTY_CYCLES",
 		.desc = "Problem-State Level-1 D-Cache Penalty Cycle Count",
 	},
+};
+
+static const pme_cpumf_ctr_t cpumcf_fvn3_counters[] = {
+	{
+		.ctrnum = 0,
+		.ctrset = CPUMF_CTRSET_BASIC,
+		.name = "CPU_CYCLES",
+		.desc = "Cycle Count",
+	},
+	{
+		.ctrnum = 1,
+		.ctrset = CPUMF_CTRSET_BASIC,
+		.name = "INSTRUCTIONS",
+		.desc = "Instruction Count",
+	},
+	{
+		.ctrnum = 2,
+		.ctrset = CPUMF_CTRSET_BASIC,
+		.name = "L1I_DIR_WRITES",
+		.desc = "Level-1 I-Cache Directory Write Count",
+	},
+	{
+		.ctrnum = 3,
+		.ctrset = CPUMF_CTRSET_BASIC,
+		.name = "L1I_PENALTY_CYCLES",
+		.desc = "Level-1 I-Cache Penalty Cycle Count",
+	},
+	{
+		.ctrnum = 4,
+		.ctrset = CPUMF_CTRSET_BASIC,
+		.name = "L1D_DIR_WRITES",
+		.desc = "Level-1 D-Cache Directory Write Count",
+	},
+	{
+		.ctrnum = 5,
+		.ctrset = CPUMF_CTRSET_BASIC,
+		.name = "L1D_PENALTY_CYCLES",
+		.desc = "Level-1 D-Cache Penalty Cycle Count",
+	},
+	{
+		.ctrnum = 32,
+		.ctrset = CPUMF_CTRSET_PROBLEM_STATE,
+		.name = "PROBLEM_STATE_CPU_CYCLES",
+		.desc = "Problem-State Cycle Count",
+	},
+	{
+		.ctrnum = 33,
+		.ctrset = CPUMF_CTRSET_PROBLEM_STATE,
+		.name = "PROBLEM_STATE_INSTRUCTIONS",
+		.desc = "Problem-State Instruction Count",
+	},
+};
+
+static const pme_cpumf_ctr_t cpumcf_svn_generic_counters[] = {
 	{
 		.ctrnum = 64,
 		.ctrset = CPUMF_CTRSET_CRYPTO,
@@ -1293,6 +1347,434 @@ static const pme_cpumf_ctr_t cpumcf_z13_counters[] = {
 	},
 };
 
+static const pme_cpumf_ctr_t cpumcf_z14_counters[] = {
+	{
+		.ctrnum = 128,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_WRITES_RO_EXCL",
+		.desc = "Counter:128 Name:L1D_WRITES_RO_EXCL A directory"
+			" write to the Level-1 Data cache where the line was"
+			" originally in a Read-Only state in the cache but"
+			" has been updated to be in the Exclusive state that"
+			" allows stores to the cache line",
+	},
+	{
+		.ctrnum = 129,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "DTLB2_WRITES",
+		.desc = "A translation has been written into The Translation"
+			" Lookaside Buffer 2 (TLB2) and the request was made"
+			" by the data cache",
+	},
+	{
+		.ctrnum = 130,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "DTLB2_MISSES",
+		.desc = "A TLB2 miss is in progress for a request made by"
+			" the data cache. Incremented by one for every TLB2"
+			" miss in progress for the Level-1 Data cache on this"
+			" cycle",
+	},
+	{
+		.ctrnum = 131,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "DTLB2_HPAGE_WRITES",
+		.desc = "A translation entry was written into the Combined"
+			" Region and Segment Table Entry array in the Level-2"
+			" TLB for a one-megabyte page or a Last Host"
+			" Translation was done",
+	},
+	{
+		.ctrnum = 132,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "DTLB2_GPAGE_WRITES",
+		.desc = "A translation entry for a two-gigabyte page was"
+			" written into the Level-2 TLB",
+	},
+	{
+		.ctrnum = 133,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_L2D_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from the Level-2 Data cache",
+	},
+	{
+		.ctrnum = 134,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "ITLB2_WRITES",
+		.desc = "A translation entry has been written into the"
+			" Translation Lookaside Buffer 2 (TLB2) and the"
+			" request was made by the instruction cache",
+	},
+	{
+		.ctrnum = 135,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "ITLB2_MISSES",
+		.desc = "A TLB2 miss is in progress for a request made by"
+			" the instruction cache. Incremented by one for every"
+			" TLB2 miss in progress for the Level-1 Instruction"
+			" cache in a cycle",
+	},
+	{
+		.ctrnum = 136,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_L2I_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from the Level-2 Instruction cache",
+	},
+	{
+		.ctrnum = 137,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TLB2_PTE_WRITES",
+		.desc = "A translation entry was written into the Page Table"
+			" Entry array in the Level-2 TLB",
+	},
+	{
+		.ctrnum = 138,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TLB2_CRSTE_WRITES",
+		.desc = "Translation entries were written into the Combined"
+			" Region and Segment Table Entry array and the Page"
+			" Table Entry array in the Level-2 TLB",
+	},
+	{
+		.ctrnum = 139,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TLB2_ENGINES_BUSY",
+		.desc = "The number of Level-2 TLB translation engines busy"
+			" in a cycle",
+	},
+	{
+		.ctrnum = 140,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TX_C_TEND",
+		.desc = "A TEND instruction has completed in a constrained"
+			" transactional-execution mode",
+	},
+	{
+		.ctrnum = 141,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TX_NC_TEND",
+		.desc = "A TEND instruction has completed in a non-"
+			" constrained transactional-execution mode",
+	},
+	{
+		.ctrnum = 143,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1C_TLB2_MISSES",
+		.desc = "Increments by one for any cycle where a level-1"
+			" cache or level-2 TLB miss is in progress",
+	},
+	{
+		.ctrnum = 144,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONCHIP_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Chip Level-3 cache without intervention",
+	},
+	{
+		.ctrnum = 145,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONCHIP_MEMORY_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from On-Chip memory",
+	},
+	{
+		.ctrnum = 146,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONCHIP_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Chip Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 147,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONCLUSTER_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from On-Cluster Level-3 cache withountervention",
+	},
+	{
+		.ctrnum = 148,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONCLUSTER_MEMORY_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Cluster memory",
+	},
+	{
+		.ctrnum = 149,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONCLUSTER_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Cluster Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 150,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFCLUSTER_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Cluster Level-3 cache without"
+			" intervention",
+	},
+	{
+		.ctrnum = 151,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFCLUSTER_MEMORY_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from Off-Cluster memory",
+	},
+	{
+		.ctrnum = 152,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFCLUSTER_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Cluster Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 153,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Level-3 cache without"
+			" intervention",
+	},
+	{
+		.ctrnum = 154,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_MEMORY_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from Off-Drawer memory",
+	},
+	{
+		.ctrnum = 155,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 156,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONDRAWER_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from On-Drawer Level-4 cache",
+	},
+	{
+		.ctrnum = 157,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_OFFDRAWER_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from Off-Drawer Level-4 cache",
+	},
+	{
+		.ctrnum = 158,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1D_ONCHIP_L3_SOURCED_WRITES_RO",
+		.desc = "A directory write to the Level-1 Data cache"
+			" directory where the returned cache line was sourced"
+			" from On-Chip L3 but a read-only invalidate was done"
+			" to remove other copies of the cache line",
+	},
+	{
+		.ctrnum = 162,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONCHIP_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache ine was sourced"
+			" from an On-Chip Level-3 cache without intervention",
+	},
+	{
+		.ctrnum = 163,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONCHIP_MEMORY_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache ine was sourced"
+			" from On-Chip memory",
+	},
+	{
+		.ctrnum = 164,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONCHIP_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache ine was sourced"
+			" from an On-Chip Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 165,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONCLUSTER_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Cluster Level-3 cache without"
+			" intervention",
+	},
+	{
+		.ctrnum = 166,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONCLUSTER_MEMORY_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an On-Cluster memory",
+	},
+	{
+		.ctrnum = 167,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONCLUSTER_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from On-Cluster Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 168,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFCLUSTER_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Cluster Level-3 cache without"
+			" intervention",
+	},
+	{
+		.ctrnum = 169,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFCLUSTER_MEMORY_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from Off-Cluster memory",
+	},
+	{
+		.ctrnum = 170,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFCLUSTER_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Cluster Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 171,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_L3_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Level-3 cache without"
+			" intervention",
+	},
+	{
+		.ctrnum = 172,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_MEMORY_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from Off-Drawer memory",
+	},
+	{
+		.ctrnum = 173,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_L3_SOURCED_WRITES_IV",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from an Off-Drawer Level-3 cache with intervention",
+	},
+	{
+		.ctrnum = 174,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_ONDRAWER_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from On-Drawer Level-4 cache",
+	},
+	{
+		.ctrnum = 175,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "L1I_OFFDRAWER_L4_SOURCED_WRITES",
+		.desc = "A directory write to the Level-1 Instruction cache"
+			" directory where the returned cache line was sourced"
+			" from Off-Drawer Level-4 cache",
+	},
+	{
+		.ctrnum = 224,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "BCD_DFP_EXECUTION_SLOTS",
+		.desc = "Count of floating point execution slots used for"
+			" finished Binary Coded Decimal to Decimal Floating"
+			" Point conversions. Instructions: CDZT, CXZT, CZDT,"
+			" CZXT",
+	},
+	{
+		.ctrnum = 225,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "VX_BCD_EXECUTION_SLOTS",
+		.desc = "Count of floating point execution slots used for"
+			" finished vector arithmetic Binary Coded Decimal"
+			" instructions. Instructions: VAP, VSP, VMPVMSP, VDP,"
+			" VSDP, VRP, VLIP, VSRP, VPSOPVCP, VTP, VPKZ, VUPKZ,"
+			" VCVB, VCVBG, VCVDVCVDG",
+	},
+	{
+		.ctrnum = 226,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "DECIMAL_INSTRUCTIONS",
+		.desc = "Decimal instructions dispatched. Instructions: CVB,"
+			" CVD, AP, CP, DP, ED, EDMK, MP, SRP, SP, ZAP",
+	},
+	{
+		.ctrnum = 232,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "LAST_HOST_TRANSLATIONS",
+		.desc = "Last Host Translation done",
+	},
+	{
+		.ctrnum = 243,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TX_NC_TABORT",
+		.desc = "A transaction abort has occurred in a non-"
+			" constrained transactional-execution mode",
+	},
+	{
+		.ctrnum = 244,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TX_C_TABORT_NO_SPECIAL",
+		.desc = "A transaction abort has occurred in a constrained"
+			" transactional-execution mode and the CPU is not"
+			" using any special logic to allow the transaction to"
+			" complete",
+	},
+	{
+		.ctrnum = 245,
+		.ctrset = CPUMF_CTRSET_EXTENDED,
+		.name = "TX_C_TABORT_SPECIAL",
+		.desc = "A transaction abort has occurred in a constrained"
+			" transactional-execution mode and the CPU is using"
+			" special logic to allow the transaction to complete",
+	},
+	{
+		.ctrnum = 448,
+		.ctrset = CPUMF_CTRSET_MT_DIAG,
+		.name = "MT_DIAG_CYCLES_ONE_THR_ACTIVE",
+		.desc = "Cycle count with one thread active",
+	},
+	{
+		.ctrnum = 449,
+		.ctrset = CPUMF_CTRSET_MT_DIAG,
+		.name = "MT_DIAG_CYCLES_TWO_THR_ACTIVE",
+		.desc = "Cycle count with two threads active",
+	},
+};
+
 static const pme_cpumf_ctr_t cpumsf_counters[] = {
 	{
 		.ctrnum = 720896,
diff --git a/lib/pfmlib_s390x_cpumf.c b/lib/pfmlib_s390x_cpumf.c
index 7273962..62b1457 100644
--- a/lib/pfmlib_s390x_cpumf.c
+++ b/lib/pfmlib_s390x_cpumf.c
@@ -37,6 +37,8 @@
 #define CPUM_CF_DEVICE_DIR  "/sys/bus/event_source/devices/cpum_cf"
 #define CPUM_SF_DEVICE_DIR  "/sys/bus/event_source/devices/cpum_sf"
 #define SYS_INFO	    "/proc/sysinfo"
+#define SERVICE_LEVEL	    "/proc/service_levels"
+#define CF_VERSION_STR	    "CPU-MF: Counter facility: version="
 
 
 /* CPU-measurement counter list (pmu events) */
@@ -99,6 +101,37 @@ out:
 	return machine_type;
 }
 
+static void get_cf_version(unsigned int *cfvn, unsigned int *csvn)
+{
+	int rc;
+	FILE *fp;
+	char *buffer;
+	size_t buflen;
+
+	*cfvn = *csvn = 0;
+	fp = fopen(SERVICE_LEVEL, "r");
+	if (fp == NULL)
+		return;
+
+	buffer = NULL;
+	while (pfmlib_getl(&buffer, &buflen, fp) != -1) {
+		/* skip empty lines */
+		if (*buffer == '\n')
+			continue;
+
+		/* look for 'CPU-MF: Counter facility: version=' entry */
+		if (!strncmp(CF_VERSION_STR, buffer, strlen(CF_VERSION_STR))) {
+			rc = sscanf(buffer + strlen(CF_VERSION_STR), "%u.%u",
+				    cfvn, csvn);
+			if (rc != 2)
+				*cfvn = *csvn = 0;
+			break;
+		}
+	}
+	fclose(fp);
+	free(buffer);
+}
+
 /* Initialize the PMU representation for CPUMF.
  *
  * Set up the PMU events array based on
@@ -108,8 +141,33 @@ out:
 static int pfm_cpumcf_init(void *this)
 {
 	pfmlib_pmu_t *pmu = this;
-	const pme_cpumf_ctr_t *ext_set;
-	size_t generic_count, ext_set_count;
+	unsigned int cfvn, csvn;
+	const pme_cpumf_ctr_t *cfvn_set, *csvn_set, *ext_set;
+	size_t cfvn_set_count, csvn_set_count, ext_set_count, pme_count;
+
+	/* obtain counter first/second version number */
+	get_cf_version(&cfvn, &csvn);
+
+	/* counters based on first version number */
+	switch (cfvn)
+	{
+	case 1:
+		cfvn_set = cpumcf_fvn1_counters;
+		cfvn_set_count = LIBPFM_ARRAY_SIZE(cpumcf_fvn1_counters);
+		break;
+	case 3:
+		cfvn_set = cpumcf_fvn3_counters;
+		cfvn_set_count = LIBPFM_ARRAY_SIZE(cpumcf_fvn3_counters);
+		break;
+	default:
+		cfvn_set = NULL;
+		cfvn_set_count = 0;
+		break;
+	}
+
+	/* counters based on second version number */
+	csvn_set = cpumcf_svn_generic_counters;
+	csvn_set_count = LIBPFM_ARRAY_SIZE(cpumcf_svn_generic_counters);
 
 	/* check and assign a machine-specific extended counter set */
 	switch (get_machine_type()) {
@@ -133,6 +191,10 @@ static int pfm_cpumcf_init(void *this)
 		ext_set = cpumcf_z13_counters;
 		ext_set_count = LIBPFM_ARRAY_SIZE(cpumcf_z13_counters);
 		break;
+	case 3906:  /* IBM z14  */
+		ext_set = cpumcf_z14_counters;
+		ext_set_count = LIBPFM_ARRAY_SIZE(cpumcf_z14_counters);
+		break;
 	default:
 		/* No extended counter set for this machine type or there
 		 * was an error retrieving the machine type */
@@ -141,20 +203,30 @@ static int pfm_cpumcf_init(void *this)
 		break;
 	}
 
-	generic_count = LIBPFM_ARRAY_SIZE(cpumcf_generic_counters);
-
-	cpumcf_pe = calloc(sizeof(*cpumcf_pe), generic_count + ext_set_count);
+	cpumcf_pe = calloc(sizeof(*cpumcf_pe),
+			   cfvn_set_count + csvn_set_count + ext_set_count);
 	if (cpumcf_pe == NULL)
 		return PFM_ERR_NOMEM;
 
-	memcpy(cpumcf_pe, cpumcf_generic_counters,
-	       sizeof(*cpumcf_pe) * generic_count);
+	pme_count = 0;
+	memcpy(cpumcf_pe, cfvn_set, sizeof(*cpumcf_pe) * cfvn_set_count);
+	pme_count += cfvn_set_count;
+	memcpy((void *) (cpumcf_pe + pme_count), csvn_set,
+	       sizeof(*cpumcf_pe) * csvn_set_count);
+	pme_count += csvn_set_count;
 	if (ext_set_count)
-		memcpy((void *) (cpumcf_pe + generic_count),
+		memcpy((void *) (cpumcf_pe + pme_count),
 		       ext_set, sizeof(*cpumcf_pe) * ext_set_count);
+	pme_count += ext_set_count;
 
 	pmu->pe = cpumcf_pe;
-	pmu->pme_count = generic_count + ext_set_count;
+	pmu->pme_count = pme_count;
+
+	/* CPUM-CF provides fixed counters only. The number of installed
+	 * counters depends on the version and hardware model up to
+	 * CPUMF_COUNTER_MAX.
+	 */
+	pmu->num_fixed_cntrs = pme_count;
 
 	return PFM_SUCCESS;
 }
@@ -276,8 +348,8 @@ pfmlib_pmu_t s390x_cpum_cf_support = {
 	.num_fixed_cntrs = CPUMF_COUNTER_MAX,	/* fixed counters only */
 	.max_encoding	 = 1,
 
-	.pe		 = cpumcf_generic_counters,
-	.pme_count	 = LIBPFM_ARRAY_SIZE(cpumcf_generic_counters),
+	.pe		 = NULL,
+	.pme_count	 = 0,
 
 	.pmu_detect    = pfm_cpumcf_detect,
 	.pmu_init      = pfm_cpumcf_init,
diff --git a/lib/pfmlib_s390x_priv.h b/lib/pfmlib_s390x_priv.h
index 22c775a..48a96c3 100644
--- a/lib/pfmlib_s390x_priv.h
+++ b/lib/pfmlib_s390x_priv.h
@@ -1,7 +1,7 @@
 #ifndef __PFMLIB_S390X_PRIV_H__
 #define __PFMLIB_S390X_PRIV_H__
 
-#define CPUMF_COUNTER_MAX	    256
+#define CPUMF_COUNTER_MAX	    0xffff
 typedef struct {
 	uint64_t ctrnum;	    /* counter number */
 	unsigned int ctrset;	    /* counter set */
commit 31ab4b33773750fbd13a1824e485805b70fc0bff
Author: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Date:   Fri Feb 9 09:42:07 2018 +0100

    s390/cpumf: check for counter facility availability
    
    If the counter facility is not available, counter information
    are not being set up.  Introduce checks to protect against
    access to counter information in that case.
    
    Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>

diff --git a/lib/pfmlib_s390x_cpumf.c b/lib/pfmlib_s390x_cpumf.c
index 62b1457..4e03fc4 100644
--- a/lib/pfmlib_s390x_cpumf.c
+++ b/lib/pfmlib_s390x_cpumf.c
@@ -254,7 +254,9 @@ static int pfm_cpumf_get_encoding(void *this, pfmlib_event_desc_t *e)
 
 static int pfm_cpumf_get_event_first(void *this)
 {
-	return 0;
+	pfmlib_pmu_t *pmu = this;
+
+	return !!pmu->pme_count ? 0 : -1;
 }
 
 static int pfm_cpumf_get_event_next(void *this, int idx)
@@ -317,6 +319,9 @@ static int pfm_cpumf_get_event_info(void *this, int idx,
 	pfmlib_pmu_t *pmu = this;
 	const pme_cpumf_ctr_t *pe = this_pe(this);
 
+	if (idx >= pmu->pme_count)
+		return PFM_ERR_INVAL;
+
 	info->name = pe[idx].name;
 	info->desc = pe[idx].desc;
 	info->code = pe[idx].ctrnum;
